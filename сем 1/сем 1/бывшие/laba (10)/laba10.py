## Талышева Олеся ИУ7-15Б
## Программа вычисляет приближенное значение интеграла заданной в ней функции методами срединных прямоугольников
## и парабол. Вводятся начало и конец отрезка интегрирования, а также N1 и N2 - количества участков разбиения.
## Строится таблица с результатами, определяется на основе заданной в программе первообразной наиболее точный метод, 
## точности всех методов выводятся в таблицу. Для менее точного метода итерационно вычисляется количество участков 
## разбиения, для которого интеграл будет вычислен с заданной точностью, на основе формулы |I(N) - I(2N)| < E.

# Функция считает первообразную интегрируемой функции
def First_Fun(x):
    y = 1/3 * x**3
    return y

# Функция считает значение интегрируемой функции
def fun(x):
    y = x**2
    return y

# Ввод начала и конца отрезка интегрирования, а также N1 и N2 - количества участков разбиения
st = None
while st == None:
    try:
        st, fin = map(float, input('Введите начало и конец отрезка интегрирования через пробел: ').split())
    except ValueError:
        print('Ошибка ввода. Нужно ввести числа.')
    else:
        if st == fin:
            print('Концы отрезка интегрирования равны. Интеграл = 0. Повторите попытку ввода.')
            st = None
if fin < st:
    fin, st = st, fin
# Считаем длину отрезка интегрирования
leng = fin - st
N1 = None
while N1 == None:
    try:
        N1, N2 = map(int, input('Введите количества участков разбиения через пробел: ').split())
    except ValueError:
        print('Ошибка ввода. Нужно ввести числа. Повторите попытку ввода.')
    else:
        if N1 <= 0 or N2 <= 0:
            print('Неверный ввод. Числа должны быть положительными. Повторите попытку ввода.')
            N1 = None

# Считаем интеграл функции методом срединных прямоугольников
def box(N):
    leng_P = leng / N # длина части отрезка
    st_P = st # Начало части отрезка
    S = 0 # переменная для подсчёта интеграла
    # Делаем количество шагов N
    for i in range(N):
        fin_P = st_P + leng_P # Конец части отрезка
        x = (fin_P + st_P) / 2 # Cередина части отрезка
        y = fun(x) # считаем значение функции в х
        S_P = leng_P * y # площадь части отрезка
        S += S_P # увеличиваем переменную интеграла на площадь части отрезка
        st_P += leng_P # передвигаем начало части отрезка
    return S # возвращает интеграл

# Вычисляем интеграл по методу срединных прямоугольников с разбиением N1
S_box_N1 = box(N1)

# Вычисляем интеграл по методу срединных прямоугольников с разбиением N2
S_box_N2 = box(N2)

# Считаем производную функции методом срединных прямоугольников
def par(N):
    # Делаем N чётным
    if N % 2 != 0:
        N += 1
    leng_P = leng / N # длина части отрезка
    # Считаем интеграл по формуле Симпсона
    S = fun(st) + fun(fin)
    x = st
    for i in range(1, N):
        x += leng_P
        S += 2 * fun(x) if i % 2 == 0 else 4 * fun(x)
    S *= leng_P / 3
    return S


# Вычисляем интеграл по методу парабол с разбиением N1
S_par_N1 = par(N1)

# Вычисляем интеграл по методу парабол с разбиением N2
S_par_N2 = par(N2)

# Вывод таблицы c результатами интегрирования
print('Результаты интегрирования:')
print('-' * 64, sep = '')
print('|', ' ' * 20, '|', ' N1', ' ' * 17, '|', ' N2', ' ' * 17, '|', sep = '')
print('-' * 64, sep = '')
print('| Метод 1', ' ' * 12, '| ', f'{S_box_N1:5.2f}', ' ' * (19 - len(f'{S_box_N1:5.2f}')), '| ',\
      f'{S_box_N2:5.2f}', ' ' * (19 - len(f'{S_box_N2:5.2f}')), '|', sep = '')
print('-' * 64, sep = '')
print('| Метод 2', ' ' * 12, '| ', f'{S_par_N1:5.2f}', ' ' * (19 - len(f'{S_par_N1:5.2f}')), '| ',\
      f'{S_par_N2:5.2f}', ' ' * (19 - len(f'{S_par_N2:5.2f}')), '|', sep = '')
print('-' * 64, sep = '')

# Функция вычисляет точность интегрирования
def Int(S):
    dif = abs(S - (First_Fun(fin) - First_Fun(st)))
    return dif

# Вывод таблицы c результатами вычисления точности интегрирования
print('Точность интегрирования:')
print('-' * 64, sep = '')
print('|', ' ' * 20, '|', ' N1', ' ' * 17, '|', ' N2', ' ' * 17, '|', sep = '')
print('-' * 64, sep = '')
print('| Метод 1', ' ' * 12, '| ', f'{Int(S_box_N1):5.2f}', ' ' * (19 - len(f'{Int(S_box_N1):5.2f}')), '| ',\
      f'{Int(S_box_N2):5.2f}', ' ' * (19 - len(f'{Int(S_box_N2):5.2f}')), '|', sep = '')
print('-' * 64, sep = '')
print('| Метод 2', ' ' * 12, '| ', f'{Int(S_par_N1):5.2f}', ' ' * (19 - len(f'{Int(S_par_N1):5.2f}')), '| ',\
      f'{Int(S_par_N2):5.2f}', ' ' * (19 - len(f'{Int(S_par_N2):5.2f}')), '|', sep = '')
print('-' * 64, sep = '')

# Выбираем самое точное значение интеграла и сохраняем не самое точное и его количество итераций
S = sorted([Int(S_box_N1), Int(S_box_N2), Int(S_par_N1), Int(S_par_N2)])
flag = False
if Int(S_box_N1) == S[0] or Int(S_box_N2) == S[0]:
    print('Метод 1 наиболее точный')
    flag = True
else:
    print('Метод 2 наиболее точный')

# Вводится точность и считается количество итераций, при котором достигается данная точность
E = None
while E == None:
    try:
        E = float(input('Введите точность: '))
    except ValueError:
        print('Ошибка ввода. Нужно ввести число. Повторите попытку ввода.')
    else:
        if E <= 0:
            print('Неверный ввод. Точность должна быть положительной. Повторите попытку ввода.')
            E = None
n = 1
if flag:
    while abs(par(n * 2) - par(n)) >= E:
        n *= 2
    print('Искомая точность для метода 2 достигается при следующем количестве итераций: ', n)
else:
    while abs(box(n * 2) - box(n)) >= E:
        n *= 2
    print('Искомая точность для метода 1 достигается при следующем количестве итераций: ', n)

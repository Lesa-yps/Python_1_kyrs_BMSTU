''' Талышева ИУ7-15Б
В программе задан текст (фрагмент литературного
произведения из 5-7 предложений, который разбит на 7-10 строк) в виде списка строк.
Программа является текстовым редактором.'''

# Строка, с которой будет работать пользователь
# В текст нельзя вставлять "&"
s = ['   Когда он разговаривал с ней таким образом, вдруг загремела музыка. Каштанка оглянулась ',
    'и увидела, что по улице прямо на неё  шёл полк 800 * 2 + 100 солдат. Не вынося музыки, ',
    'которая расстраивала ей нервы, она заметалась и завыла. К великому её удивлению,',
    'столяр, вместо того, чтобы испугаться, завизжать и залаять, широко ',
    'улыбнулся, вытянулся во фрунт и всей 3+2 сделал под козырек. Видя, что хозяин ',
    'не протестует, Каштанка еще громче завыла и, не помня себя, ',
    'бросилась через дорогу на другой тротуар. Когда ',
    'она опомнилась, музыка уже не играла и полка не было.']

# Функция убирает лишние пробелы в тексте
def func(x):
    # Делаем все пробелы между словами равными 1
        strk = ' '
        flag = True
        while flag:
            flag = False
            for i in range(len(x)):
                if (strk + ' ') in x[i]:
                    flag = True
            if flag:
                strk += ' '
        while strk != ' ':
            for i in range(len(x)):
                if strk in x[i]:
                    x[i] = x[i].replace(strk, ' ')
            strk = strk[:-1]
        # Убираем пробелы в конце, если они есть
        for i in range(len(x)):
            if x[i] != '':
                if x[i][-1] == ' ':
                    x[i] = x[i][:-1]
        # Убираем пробелы в начале, если они есть
        for i in range(len(x)):
            if x[i] != '':
                if x[i][0] == ' ':
                    x[i] = x[i][1:]
        return x

# Функция находиит максимальную длину строки
def find_max_len_str(s):
    max_len_str = 0
    for i in range(len(s)):
        if len(s[i]) > max_len_str:
            max_len_str = len(s[i])
    return max_len_str

# Функция выравнивает текст по левому краю
def left_align(s):
    # Функция убирает лишние пробелы в тексте 
    s = func(s)
    # Находим максимальную длину строки
    max_len_str = find_max_len_str(s)
    # Дополняем все строки пробелами в конце до длины максимальной строки
    for i in range(len(s)):
        s[i] = s[i] + ' ' * (max_len_str - len(s[i]))
    return s

# Функция выравнивает текст по правому краю
def right_align(s):
    # Функция убирает лишние пробелы в тексте
    s = func(s)
    # Находим максимальную длину строки
    max_len_str = find_max_len_str(s)
    # Дополняем все строки пробелами в начале до длины максимальной строки 
    for i in range(len(s)):
        s[i] = ' ' * (max_len_str - len(s[i])) + s[i]
    return s

# Функция выравнивает текст по ширине
def middle_align(s):
    # Функция убирает лишние пробелы в тексте
    s = func(s)
    # Находим максимальную длину строки
    max_len_str = find_max_len_str(s)
    # Проходимся по всем строкам
    for i in range(len(s)):
        count = 0
        # Считаем количество пробелов в строке
        for j in range(1, len(s[i]) - 1):
            if s[i][j] == ' ' and s[i][j - 1] != ' ' and s[i][j + 1] != ' ':
                count += 1
            # Если в строке есть пробелы между словами
        if count != 0:
            # Равномерно увеличиваем пробелы стремясь сравнять длину
            # текущей строки с длиной  максимальной строки
            if ((max_len_str - len(s[i])) // count) > 0:
                k = (max_len_str - len(s[i])) // count + 1
                s[i] = s[i].replace(' ', k * ' ')
            # Пробелы, которые не распределились поровну, добавляем по одному
            # к уже существующим пробелам с конца строки
            k = (max_len_str - len(s[i])) % count
            j = len(s[i]) - 1
            flag = False
            while k > 0:
                j -= 1
                if s[i][j] == ' ' and not flag:
                    s[i] = s[i][:(j + 1)] + ' ' + s[i][(j + 1):]
                    k -= 1
                    flag = True
                elif flag and s[i][j] != ' ':
                    flag = False
    return s

# Функция удаляет слово в тексте
def del_word(s, s1):
    fl = False
    # Проходимся по всем строкам
    for i in range(len(s)):
        # В переменную fraz мы собираем строку подходящую под удаляемую
        fraz = ''
        j = 0
        # Проходимся по всем символам строки
        while j < len(s[i]):
            # В переменную-флаг запоминаем: можем ли мы начать собирать новую строку
            if j == 0:
                flag = True
            elif s[i][j - 1] == ' ':
                flag = True
            else:
                flag = False
            # Если мы собрали подходящую строку и слово закончилось, удаляем эту строку
            if fraz == s1 and not s[i][j].isalpha() and not s[i][j].isdigit():
                s[i] = s[i][:(j - len(s1))] + s[i][j:]
                fl = True
                # Сдвигаем индекс текущего элемента
                j -= len(s1) - 1
                fraz = ''
            elif fraz == s1 and (s[i][j].isalpha() or s[i][j].isdigit()) and (j != (len(s[i]) - 1)):
                    fraz = ''
            # Здесь мы собираем строку, подходящую под удаляемую
            elif fraz == s1[:len(fraz)] and s[i][j] == s1[len(fraz)]:
                if (fraz == '' and flag) or (0 < len(fraz)):
                    fraz += s[i][j]
                    # Если мы собрали строку и текущий символ последний в строке, удаляем собранную строку
                    if fraz == s1 and j == (len(s[i]) - 1):
                        s[i] = s[i][:(j - len(s1))] + s[i][j:]
                        fl = True
                        # Сдвигаем индекс текущего элемента
                        j -= len(s1)
                        fraz = ''
            # Если ни одно из условий выше не подошло, обнуляем собранную строку
            else:
                fraz = ''
            j += 1
    return s, fl

# Функция заменяет слово в тексте
def replace_word(s, s1, s2):
    fl = False
    # проходися по всем строкам
    for i in range(len(s)):
        # В переменную fraz мы собираем строку подходящую под заменяемую
        fraz = ''
        j = 0
        # Проходимся по всем символам строки
        while j < len(s[i]):
            # В переменную-флаг запоминаем: можем ли мы начать собирать новую строку
            if j == 0:
                flag = True
            elif s[i][j - 1]  in ' .,?!"();:*-+\/':
                flag = True
            else:
                flag = False
            # Если мы собрали подходящую строку и слово закончилось, заменяем эту строку
            if fraz == s1 and not s[i][j].isalpha() and not s[i][j].isdigit():
                s[i] = s[i][:(j - len(s1))] + s2 + s[i][j:]
                fl = True
                # Сдвигаем индекс текущего элемента
                j -= len(s1) - len(s2)
                fraz = ''
            elif fraz == s1 and (s[i][j].isalpha() or s[i][j].isdigit()) and (j != (len(s[i]) - 1)):
                    fraz = ''
            # Здесь мы собираем строку, подходящую под заменяемую
            elif fraz == s1[:len(fraz)] and s[i][j] == s1[len(fraz)]:
                if (fraz == '' and flag) or (0 < len(fraz)):
                    fraz += s[i][j]
                    # Если мы собрали строку и текущий символ последний в строке, заменяем собранную строку
                    if fraz == s1 and j == (len(s[i]) - 1):
                        s[i] = s[i][:(j - len(s1))] + s2
                        fl = True
                        # Сдвигаем индекс текущего элемента
                        j -= len(s1) - len(s2)
            # Если ни одно из условий выше не подошло, обнуляем собранную строку
            else:
                fraz = ''                
            j += 1
    return s, fl

# Функция все строки из списка записывает в одну строку через знак "&"
def s_to_line(s):
    line = ''
    for i in range(len(s)):
        line +=  s[i] + '&'
    return line

# Функция одну строку преобразовывает обратно в список строк, ориентируясь на знак "&"
def line_to_s(line):
    for i in range(len(s)):
        s[i] = line[:(line.find('&'))]
        line = line[(line.find('&') + 1):]
    return(s)

# Функция вычисляет арифметические выражения (+ и *) над целыми числами в тексте
def math_plus_multi(s):
    # Все строки из списка записываем в одну строки через знак "&"
    line = s_to_line(s)
    # Пока в строке будут происходить замены цикл будет выполняться
    mig = True
    while mig:
        mig = False
        j = 0
        # Проходимся по всем символам в получившейся строке
        while j < len(line):
            # Если текущий символ "+" или "*" 
            if line[j] in '+*':
                # В перепенную qz будет записано количество переходов
                # на другую строку ("&") в арифметическом выражении
                qz = 0
                # В переменных strk1 и strk2 будут записаны числа, над которыми будет
                # производиться арифметическое действие
                strk1 = strk2 = ''
                # В переменных count1 и сount2 сохранятся начало и конец арифметического выражения
                count1 = count2 = j
                # basta запоминает были ли уже цифры в строке по которой мы прошлись
                # puf запоминает были ли после цифр другие знаки по которым мы уже прошлись
                basta = puf = False
                # Проходимся по строке в обратную сторону и собираем первое число
                for k in range(j - 1, -1, -1):
                        # Если встретилась цифра
                        if line[k].isdigit():
                                if not puf:
                                        strk1 = line[k] + strk1
                                        count1 = k
                                        basta = True
                                elif puf:
                                        break
                        # Иначе если цифр до этого не было
                        elif not basta:
                                if line[k] in ' )&':
                                        if line[k] == '&':
                                                qz += 1
                                else:
                                        break
                        # иначе если цифры до этого были
                        elif basta:
                                puf = True
                                if line[k] in ' (':
                                        pass
                                # обрабатываем минусы
                                elif line[k] == '-' and strk1[0] == '-':
                                        strk1 = strk1[1:]
                                        count1 = k
                                elif line[k] == '-' and strk1[0] != '-':
                                        strk1 = '-' + strk1
                                        count1 = k
                                else:
                                        break                
                # basta запоминает были ли уже цифры в строке по которой мы прошлись
                basta = False
                # Проходимся вперёд по строке и собираем второе число
                for k in range(j + 1, len(line)):
                        # Если встретилась цифра
                        if line[k].isdigit():
                                strk2 += line[k]
                                count2 = k
                                basta = True
                        # Иначе если цифр до этого не было
                        elif not basta:
                                if line[k] in ' (&':
                                        if line[k] == '&':
                                                qz += 1
                                # обрабатываем минусы
                                elif line[k] == '-' and strk2 == '':
                                        strk2 = '-'
                                elif line[k] == '-' and strk2 == '-':
                                        strk2 = ''
                                else:
                                        break
                        # иначе если цифры до этого были
                        elif basta:
                                break
                # если получилось собрать оба числа, то выполняем с ними арифметическое действие
                # и вставляем результат в строку на место арифметического выражения, добавляя
                # в конце количество знаков "&" которое было в арифметическом выражении
                if strk1 != '' and strk2 != '-' and strk2 != '':
                    mig = True
                    if line[j] == '+':
                        strk = int(strk1) + int(strk2)
                    elif line[j] == '*':
                        strk = int(strk1) * int(strk2)
                    line = line[:count1] + str(strk) + '&' * qz + line[(count2 + 1):]
                    # Сдвигаем индекс текущего элемента
                    j += count2
            j += 1
    # Восстанавливаем список строк из обработанной строки
    s = line_to_s(line)
    return s

# Функция удаляет лишние пробелы в предложении
def func_sentence(sen):
    strk = ' '
    while (strk + ' ') in sen:
        strk += ' '
    while strk != ' ':
        sen = sen.replace(strk, ' ')
        strk = strk[:-1]
    while sen[0] == ' ':
            sen = sen[1:]
    while sen[-1] == ' ':
            sen = sen[:-1]
    return sen

# Функция удаляет предложение по координатам начала и конца из списка строк
def del_sentence(s, start_i, start_j, finish_i, finish_j):
        count = 0
        while start_i != finish_i:
            if count == 0:
                s[start_i] = s[start_i][:start_j]
            else:
                s[start_i] = ''
            start_i += 1
            count = 1
        s[finish_i] = s[finish_i][(finish_j + 1):]
        return s

# Функция выводит самое длинное предложение в тексте и удаляет его из текста
def longest_sentence(s):
    # В max_sen будет храниться самое длинное найденное предложение
    max_sen = ''
    # В max_word будет храниться количество слов в самом длинном найденном предложении
    max_word = 0
    # В k_word будет храниться количество слов в текущем собранном предложение
    k_word = 0
    # В sen будет храниться текущее собранное предложение
    sen = ''
    flag = False
    # В этих переменных сохранятся координаты начала и конца самого длинного и текущего предложения
    start_i = start_j = 0
    start_max_i = start_max_j = finish_max_i = finish_max_j = 0
    point = True
    # Проходимся по всем символам в получившейся строке
    for i in range(len(s)):
        # Добавляем пробел в конец строки для разделения слов при выводе
        s[i] += ' '
        for j in range(len(s[i])):
                if point and sen == '':
                        start_i = i
                        start_j = j
                        point = False
                # Добавляем символ в текущее собранное предложение
                sen += s[i][j]
                # Увеличиваем количество слов в текущем собранном предложении если слово закончилось
                if not s[i][j].isalpha() and not flag:
                    flag = True
                    k_word += 1
                elif flag and s[i][j].isalpha():
                    flag = False
                # Если встретился символ, обозначающий конец предложения
                if s[i][j] in '.!?':
                    # Если текущее предложение длиннее максимального, записываем на
                    # место максимально текущее и запоминаем его количество слов
                    if k_word > max_word:
                        max_sen = sen
                        max_word = k_word
                        # Сохраняем координаты конца и начала самого длинного предложения
                        start_max_i, start_max_j = start_i, start_j
                        finish_max_i, finish_max_j = i, j
                    sen = ''
                    k_word = 0
                    flag = True
                    point = True
    # Удаляем оишние пробелы из предложения 
    if max_sen != '':
            max_sen = func_sentence(max_sen)
    # Выводим предложение или сообщение о том, что оно пустое
    print()
    if len(max_sen) == 0:
        print('Предложение пустое')
    else:
        print('Самое длинное предложение:')
        print(max_sen)
    # Удаляем из строки самое длинное предложение
    s = del_sentence(s, start_max_i, start_max_j, finish_max_i, finish_max_j)
    # Удаляем добавленные ранее пробелы с конца
    for i in range(len(s)):
            if len(s[i]) > 0:
                    if s[i][-1] == ' ':
                            s[i] = s[i][:-1]
    return s

def test(s, s1, s2, n):
      if s1 == '':
                fl = False
                if n == 4:
                        print('\nВведена пустая строка. Текст не изменился.')
                elif n == 5:
                        print('\nПервая строка введена пустой. Текст не изменился.')
        # Проверка на наличие в тексте удаляемого слова
      else:
                if n == 4:
                            s, fl = del_word(s, s1)
                elif n == 5:
                            s, fl = replace_word(s, s1, s2)
                if not fl:
                    print('\nЗаданного слова нет в тексте. Текст не изменился.')
      return fl, s
# Цикл прекратит работу при вводе 0
n = None
while n != 0:
    fl = True 
    # Вывод на экран меню
    print('МЕНЮ:')
    print('          0. Выйти из программы.\n\
          1. Выровнять текст по левому краю.\n\
          2. Выровнять текст по правому краю.\n\
          3. Выровнять текст по ширине.\n\
          4. Удаление всех вхождений заданного слова.\n\
          5. Замена одного слова другим во всём тексте.\n\
          6. Вычисление арифметических выражений (+ и *) над целыми числами внутри текста.\n\
          7. Найти (вывести на экран) и затем удалить самое длинное по количеству слов предложение.')
    # Ввод пользователем номера действия
    n = None
    while n == None:
        try:
            n = int(input('Выберите действие которое необходимо совершить: '))
        except ValueError:
            print('Ошибка ввода. Введённое значение должно быть целым числом. Повторите попытку.')
        else:
            if n < 0 or n > 7:
                print('Ошибка ввода. Введённое значение должно быть цифрой, лежащей в отрезке от 0 до 7. Повторите попытку.')
                n = None
            elif n == 0:
                a = None
                while a != 'y' and a != 'n':
                    if a == None:
                        a = str(input('Вы уверены, что хотите завершить сеанс? Нажмите "y" - "да" или "n" - "нет": '))
                    else:
                        a = str(input('Ошибка ввода. Введите "y" - "да" или "n" - "нет": '))
                if a == 'n':
                    n = None
    # При вводе действия 1 текст выравнивается по левому краю   
    if n == 1:
        s = left_align(s)
    # При вводе действия 2 текст выравнивается по правому краю 
    elif n == 2:
        s = right_align(s)
    # При вводе действия 3 текст выравнивается по ширине      
    elif n == 3:
        s = middle_align(s)
    # При вводе действия 4 в тексте удаляется слово
    elif n == 4:
        s1 = str(input('Введите слово, которое нужно удалить: '))
        s2 = None
        # Проверка на пустоту введенной строки
        fl, s = test(s, s1, s2, n)
    # При вводе действия 5 в тексте слово 'Каштанка' заменяется на слово 'Бобик'
    elif n == 5:
        s1 = str(input('Введите слово, которое нужно заменить: '))
        s2 = str(input('Введите слово, на которое нужно заменить: '))
        # Проверка на пустоту введенной строки
        fl, s = test(s, s1, s2, n)
    # При вводе действия 6 в тексте вычисляются арифметические выражения (+ и *) над целыми числами
    elif n == 6:
        s = math_plus_multi(s)
    # При вводе действия 7 выведется на экран и удалится из текста самое длинное предлложение в тексте
    elif n == 7:
        s = longest_sentence(s)
    # Проверка текста на пустоту
    flag = False
    for i in range(len(s)):
        for j in range(len(s[i])):
            if s[i][j] != ' ':
                flag = True
    # Вывод результата работы программы
    print()
    if flag and n != 0:
        if fl:
                print('Преобразованный текст:', end = '\n\n')
        else:
                print()
        for i in range(len(s)):
            print(s[i])
    elif n == 0:
        print('Сеанс окончен')
    else:
        print('Текст пуст')
    print()

ЭТО НЕ ТО:
*Генераторы списков Python:
[выражение for item in итерируемое множество if условие]
*Генераторы множеств:
{выражение for item in итерируемое множество if условие}
(разница только в {})

ВОТ ЗДЕСЬ ТО:

*Выражения-генераторы
Генераторы Python — класс функций, которые позволяют создавать и хранить в памяти собственные итераторы, возвращающие значение функций по запросу. Генераторы обрабатывают данные порционно, шаг за шагом, и применяются при работе с большими объемами информации, когда возникает риск переполнения памяти.
Объявление генераторных выражений синтаксически похоже на создание словарей или списков, но, в отличие от списков, генераторы не хранят все значения выполняемой функции в памяти, а только последний элемент последовательности, условие перехода или прерывания.
общий вид:
(выражение for item in итерируемый объект if условие)

Возьмем в качестве примера генераторное выражение, возводящее в куб числа от 1 до 5:
n = (i**3 for i in range(1, 6))
print(n)
>
<generator object <genexpr> at 0x7fb6dd886510>
При выводе переменной n на печать интерпретатор сообщает о том, что созданный объект — генератор. Для вычисления очередного значения используется метод next():
print(next(n))
>1
print(next(n))
>8
print(next(n))
>27
print(next(n))
>64
print(next(n))
>125
print(next(n))
>
StopIteration
Выполним то же самое с использованием цикла for:
n = (i**3 for i in range(1, 6))
for i in n:
print(i)
>
1
8
27
64
125
Метод next(n) последовательно рассчитывает и выводит значения:
1, 8, 27, 64, 125. При этом происходит стирание предыдущих значений из памяти. Во время 6-й итерации все значения будут удалены, поэтому интерпретатор вызовет исключение StopIteration.
Таким образом, генератор позволяет лишь единожды пройтись по элементам объекта и его повторное использование невозможно — нужно создавать новый.
Это выражение — частный случай использования функции-генератора.
https://youtu.be/vn6bV6BYm7w

*Функции-генераторы
Генераторная функция определяется при помощи той же инструкции, что и обычная, — def. Отличие заключается в использовании yield, возвращающей объект-генератор, вместо инструкции return, сразу же возвращающей значение. Рассмотрим работу функции-генератора на примере чисел Фибоначчи:
def func(n):
fb1 = 0
fb2 = 1
for i in range(1,n):
yield fb2
fb_sum = fb1+fb2
fb1 = fb2
fb2 = fb_sum
fb = func(7)
print(fb)
for i in fb:
print(i)
>
<generator object func at 0x7f87e275e510>
1
1
2
3
5
8
Как видим, из консоли при вызове функции func(7) создается генератор fb.
При каждой новой итерации оператор yield приостанавливает выполнение следующих инструкций и возвращает значение fb2. Дальнейшие вызовы метода next(fb) приведут к тому, что выполнение функции продолжится с начала до следующего оператора yield. При этом, как можем заметить, значения промежуточных переменных fb1 и fb_sum фиксируются и изменяются в соответствии с кодом.
Функция-генератор поддерживает использование нескольких операторов yield. В этом случае возвратится значение справа от оператора, а код при последующем next() выполнится так же до следующего yield. Таким образом можно создавать сопрограммы-функции с возможностью приостанавливать и возобновлять выполнение программы в точках входа и выхода yield.
Рассмотрим еще один пример, где функция-генератор воспроизводит бесконечно длинную последовательность чисел.
def halfs(next_half = 0.0):
while True:
yield next_half
next_half += 0.5
Функция возвращает числа 0, 0.5, 1, 1.5 и т. д. до бесконечности.
Воспользуемся этой функцией для создания списка чисел, удовлетворяющих условию n < 3:
res = []
for i in halfs():
res. append(i)
if i >= 2.0:
break
print (res)
>
[0.0, 0.5, 1.0, 1.5, 2.0]
При каждом вызове функция halfs возвращает генератор, который увеличивает текущее значение на 0.5.
Значение можно не только вернуть, но еще и передать его в генератор с помощью метода send()
def triple_numbers():
while True:
n = yield
yield n * 3
g = triple_number()
next(g)
print(g.send(10))
next(g)
print(g.send(50))
>
10
50
При помощи метода throw() можно обрабатывать исключения:
def triple_numbers(num):
while True:
num *= 3
yield num
gen = triple_numbers(3)
for i in gen:
if i > 100:
gen.throw(Exception(«Error!»))
print(i)
>
9
27
81
Exception: Error!
Программа создает генератор, бесконечно умножающий пользовательское число на 3 до тех пор, пока оно не превысит 100, что вызовет исключение Error.
При помощи метода close() можно принудительно остановить выполнение функции генератора:
def triple_numbers(num):
while True:
num *= 3
yield num
gen = triple_numbers(3)
for i in gen:
if i > 100:
gen.close()
print(i)
>
9
27
81
243
Вызов метода close() генерирует исключение GeneratorExit в точке последнего вызова yield. Нет необходимости перехватывать это исключение, поскольку close() делает это автоматически. При этом сообщения об ошибке не возникает и последняя инструкция print(i) в цикле for успешно выполняется (на печать выводится число 243).

yeild:
https://youtu.be/8cMMO8fks-k
https://youtu.be/ZY6uHybLoZA